<?php
/*
 * Plugin Name: WordPress Exporter v2 Extension
 * Description: Demonstrates how a plugin can extend an export
 * Version: 0.1
 * Author: Paul V. Biron/Sparrow Hawk Computing
 * Author URI: http://sparrowhawkcomputing.com/
 * Plugin URI: https://github.com/pbiron/WordPress-Exporter-extension
 */

/*
 * This plugin is intended to be used in conjunction is
 * http://github.com/pbiron/WordPress-Exporter.
 *
 * It demonstrates how plugins can extend an export in various ways:
 *
 * 1. actually have "export filters" do something useful :-)
 * 2. add extension markup to the WXR generated by the exporter
 */

 /**
 * add export filters to allow exporting:
 *
 * 1. terms from specific taxonomies
 * 2. specific users
 *
 * without exporting any posts
 *
 * This action is in the standard exporter.  However, the necessary hooks to do
 * ANYTHING with these export filters is not.  Those necessary hooks are in
 * http://github.com/pbiron/WordPress-Exporter and are taken advantage of in
 * this plugin.
 */
add_action( 'export_filters', function () {
 ?>
 	<p><label><input type="radio" name="content" value="taxonomies"> Taxonomies</label></p>
	<ul id="taxonomies-filters" class="export-filters" style="display: none;">
		<li>
			<fieldset>
			<?php
			foreach ( get_taxonomies( array(), 'objects') as $tax ) {
			 ?>
			<label class="label-responsive">
				<input name="taxonomies[]" id="taxonomies-<?php echo $tax->name ?>" type='checkbox' value='<?php echo $tax->name ?>'>
			 	<?php echo $tax->labels->name ?>
			 	<br />
			 </label>
			<?php
			}
			 ?>
			</fieldset>
		</li>
	</ul>
 	<p><label><input type="radio" name="content" value="users"> Users</label></p>
	<ul id="users-filters" class="export-filters" style="display: none;">
		<li>
			<fieldset>
			<?php
			// a "real" plugin would probably also want to have dropdowns for roles, etc
			foreach ( get_users() as $user ) {
			 ?>
			<label class="label-responsive">
				<input name="users[]" id="users-<?php echo $user->ID ?>" type='checkbox' value='<?php echo $user->ID ?>'>
			 	<?php echo $user->display_name ?>
			 	<br />
			 </label>
			<?php
			}
			 ?>
			</fieldset>
		</li>
	</ul>
<?php
} );

/**
 * Display JavaScript on the page.
 */
add_action( 'admin_head', function () {
	if ( defined( 'WXR_VERSION' ) && '1.2' === WXR_VERSION) {
		/*
		 * this demonstrates the lengths that plugins must go to to
		 * get the UI of anything hooked into 'export_filters' to behave
		 * like the "built-in" export filters.
		 *
		 * It also demonstrates that even if a plugin goes to this length,
		 * a user doing an export with the standard exporter will be shocked
		 * to find that even if they set values for one of these filters
		 * that what gets exported is the same as if they had selected
		 * 'All content' :-(
		 */
?>
<script type="text/javascript">
	jQuery(document).ready(function($){
 		var form = $('#export-filters');
 		form.find('input:radio').change(function() {
			switch( $(this).val() ) {
				case 'taxonomies': $('#taxonomies-filters').slideDown(); break;
				case 'users': $('#users-filters').slideDown(); break;
			}
 		});
	});
</script>
<?php
	}
}, 11 );

/**
 * Filter the export args, so export_wp() can understand the export filters we added
 * by hooking into 'export_filters' above.
 *
 * @param array $args
 *
 * This filter is in the standard exporter.  However, the necessary hooks to do
 * ANYTHING with these export filters is not.  Those necessary hooks are in
 * http://github.com/pbiron/WordPress-Exporter and are taken advantage of in
 * this plugin.
 */
add_filter( 'export_args', function( $args ) {
	if ( 'taxonomies' === $args['content'] ) {
		$args['taxonomies'] = $_GET['taxonomies'];
	}
	elseif ( 'users' === $args['content'] ) {
		$args['users'] = $_GET['users'];
	}

	return $args;
} );

/**
 * Handle the custom export filters we added above by hooking into 'export_filters'
 *
 * @param XMLWriter $writer
 * @param array $args The arguments passed to export_wp()
 */
add_action( 'wxr_export_rss_channel', function ( $writer, $args ) {
	if ( 'taxonomies' === $args['content'] && ! empty( $args['taxonomies'] ) ) {
		// export terms from the specified taxonomies
		foreach ( get_terms( array( 'taxonomy' => $args['taxonomies'], 'hide_empty' => false ) ) as $term ) {
			wxr_write_term( $writer, $term );
		}
	}
	elseif ( 'users' === $args['content'] && ! empty( $args['users'] ) ) {
		// export the specified users
		foreach ( get_users( array( 'include' => $args['users'] ) ) as $user ) {
			wxr_write_user( $writer, $user );
		}
	}
}, 10, 2 );

/**
 * Inform the exporter that we intend to output extension elements/attributes.
 *
 * @todo The $plugins param is actually an array of the hash below.  As far as I know
 * there is no convention for this in the PHP Documentation Standards
 * (https://make.wordpress.org/core/handbook/best-practices/inline-documentation-standards/php/#1-1-parameters-that-are-arrays)

 * @param array $plugins {
 *     @type string $prefix Our "preferred" namespace prefix.
 *     @type string $namespaceURI The namespaceURI for our extension elements/attributes.
 *     @type string $slug The "file path" for our plugin (i.e., the $plugin parameter to
 *                        activate_plugin()).  The "new" importer will eventually be able
 *                        to use this (and `$url`) to inform users peforming an import
 *                        that unless this plugin is installed/activated, then some information
 *                        in the WXR instance they are importing will not actually
 *                        be imported.
 *    @type string $url The URL from which our plugin can be downloaded if it is not already
 *                      installed.
 * }
 */
add_filter( 'wxr_export_plugins', function ( $plugins ) {
	$plugins[] = array(
		'prefix' => 'shc',
		'namespaceURI' => 'http://sparrowhawkcomputing.com/shc/',
		'slug' => 'WordPress-Exporter-extension/WordPress-Exporter-extension.php',
		'url' => 'https://github.com/pbiron/WordPress-Exporter-extension',
		);

	// this is just to demonstrate that we'll get notified via
	// 'wxr_unique_prefix_http://sparrowhawkcomputing.com/wxr/' that
	// this "preferred" prefix was already taken and what prefix
	// will actually be used in the WXR instance
	$plugins[] = array(
		'prefix' => 'wxr',
		'namespaceURI' => 'http://sparrowhawkcomputing.com/wxr/',
		'slug' => 'WordPress-Exporter-extension/WordPress-Exporter-extension.php',
		'url' => 'https://github.com/pbiron/WordPress-Exporter-extension',
	);

	// this is just to demonstrate that we'll get notified AGAIN via
	// 'wxr_unique_prefix_http://sparrowhawkcomputing.com/wxr/' that
	// this "preferred" prefix was already taken and what prefix
	// will actually be used in the WXR instance
	$plugins[] = array(
		'prefix' => 'wxr',
		'namespaceURI' => 'http://sparrowhawkcomputing.com/wxr/foo/',
		'slug' => 'WordPress-Exporter-extension/WordPress-Exporter-extension.php',
		'url' => 'https://github.com/pbiron/WordPress-Exporter-extension',
	);

	return $plugins;
} ) ;

/**
 * Receive notification that the "preferred" namespace prefix we requested was already taken.
 *
 * @param string $prefix Prefix the exporter used in the namespace decl for our namespaceURI.
 */
add_action( 'wxr_unique_prefix_http://sparrowhawkcomputing.com/wxr/', function ( $prefix ) {
	// no-op, since we aren't going to output any elements in this namespace.
	// in a "real" plugin, we'd want to to store $prefix and use it for any
	// XMLWriter::writeElementNS(), etc calls
	return;
} );

/**
 * Receive notification that the "preferred" namespace prefix we requested was already taken.
 *
 * @param string $prefix Prefix the exporter used in the namespace decl for our namespaceURI.
 */
add_action( 'wxr_unique_prefix_http://sparrowhawkcomputing.com/wxr/foo/', function ( $prefix ) {
	// no-op, since we aren't going to output any elements in this namespace.
	// in a "real" plugin, we'd want to to store $prefix and use it for any
	// XMLWriter::writeElementNS(), etc calls
	return;
} );

/**
 * Export custom elements at the /rss/channel level
 *
 * In a "real" plugin, this might be used to export rows from a custom
 * table.
 *
 * Note: obviously, the standard importer would currently ignore
 * this markup.  I'm working on mods to the "new" importer
 * at https://github.com/humanmade/WordPress-Importer that adds
 * hooks so that this plugin could actually do something with this
 * markup.  Those mods should be available shortly.
 *
 * @param XMLWriter $writer
 */
add_action( 'wxr_export_rss_channel', function ( $writer ) {
	$writer->startElementNS( 'shc', 'custom_table_row', null );

	$writer->writeElementNS ( 'shc', 'column1', null, 'some content' );
	$writer->writeElementNS ( 'shc', 'column2', null, 'more content' );
	$writer->writeElementNS ( 'shc', 'column3', null, 'yet more content' );

	$writer->endElement();

/*
 * uncomment the following $writer->startElement() to see one of the advantages
 * of using XMLWriter (or any other XML-aware serializer): were a plugin
 * that was adding extension markup to WXR to forget to close an element
 * XMLWriter will close it for them when $writer->endDocument() is called by
 * the exporter (making sure that there are no "unbalanced" tags).  Of course,
 * in this case the WXR instance won't be "valid" and the importer might still
 * not be able to corrctly process the WXR instance, but at least the WXR will
 * be well-formed.
 *
 *	$writer->startElementNS( 'shc', 'custom_table_row', null );
 */
} );

/**
 * Export custom markup for a user.
 *
 * In a "real" plugin, this might be used to export rows from a custom
 * table.
 *
 * @param XMLWriter $writer
 * @param WP_User $user
 */
add_action( 'wxr_export_user', function( $writer, $user ) {
	$writer->startElementNS( 'shc', 'custom_user_row', null );

	$writer->writeElementNS( 'shc', 'col1', null, 'value 1' );
	$writer->writeElementNS( 'shc', 'col2', null, 'value 2' );

	$writer->endElement();
}, 10, 2);

add_action( 'wxr_export_nav_menu', function( $writer, $menu ) {
}, 10, 2 );

/**
 * Export custom markup for a term associated with a post.
 *
 * In a "real" plugin, this might be used to export rows from a custom
 * table.
 *
 * @param XMLWriter $writer
 * @param WP_Term $term
 */
add_action( 'wxr_export_post_term', function( $writer, $term ) {
	$writer->writeAttributeNS( 'shc', 'someAttr', null, 'some value' );
}, 10, 2 );

/**
 * Export custom markup for a comment.
 *
 * In a "real" plugin, this might be used to export rows from a custom
 * table.
 *
 * @param XMLWriter $writer
 * @param WP_Comment $comment
 */
add_action( 'wxr_export_comment', function( $writer, $comment ) {
	$writer->startElementNS( 'shc', 'comment_custom_row', null );

	$writer->writeElementNS( 'shc', 'col1', null, 'value 1' );
	$writer->writeElementNS( 'shc', 'col2', null, 'value 2' );

	$writer->endElement();
}, 10, 2 );

/**
 * Export custom markup for a meta.
 *
 * In a "real" plugin, this might be used to export rows from a custom
 * table.
 *
 * @param XMLWriter $writer
 * @param object $meta
 * @param string $type
 */
add_action( 'wxr_export_meta', function( $writer, $meta, $type ) {
	$writer->startElementNS( 'shc', 'custom_table_row', null );

	$writer->writeAttribute( 'type', $type );
	// this demonstrates the need to pass $type...since the $meta object can have
	// different members depending on what type of meta it is :-(
	$writer->writeElementNS( 'shc', 'id', null, 'user' === $type ? $meta->umeta_id : $meta->meta_id );
	$writer->writeElementNS( 'shc', 'key', null, $meta->meta_key );
	$writer->writeElementNS( 'shc', 'value', null, $meta->meta_value );

	$writer->endElement();
}, 10, 3 );

/**
 * Export custom markup for a term.
 *
 * In a "real" plugin, this might be used to export rows from a custom
 * table.
 *
 * @param XMLWriter $writer
 * @param WP_Term $term
 */
add_action( 'wxr_export_term', function( $writer, $term ) {
	$writer->writeAttributeNS( 'shc', 'disabled', null, 'false' );
	$writer->writeElementNS( 'shc', 'foo', null, $term->term_id );
}, 10, 2 );

/**
 * Export custom markup for a post.
 *
 * In a "real" plugin, this might be used to export rows from a custom
 * table that are associated with a post.
 *
 * @param XMLWriter $writer
 * @param WP_Post $post
 */
add_action( 'wxr_export_post', function ( $writer, $post ) {
	$writer->startElementNS( 'shc', 'post_custom_table_row', null );

	$writer->writeElementNS( 'shc', 'post_id', null, $post->ID );
	$writer->writeElementNS( 'shc', 'col1', null, 'val1' );
	$writer->writeElementNS( 'shc', 'col2', null, 'val2' );

	$writer->endElement();
}, 10, 2 );

 ?>