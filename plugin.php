<?php
/*
 * Plugin Name: WordPress Exporter v2 Extension
 * Description: Demonstrates how a plugin can extend an export
 * Version: 0.2
 * Author: Paul V. Biron/Sparrow Hawk Computing
 * Author URI: http://sparrowhawkcomputing.com/
 * Plugin URI: https://github.com/pbiron/wordpress-exporter-v2-extension
 * GitHub Plugin URI: https://github.com/pbiron/wordpress-exporter-v2-extension
 */

/*
 * This plugin is intended to be used in conjunction is
 * http://github.com/pbiron/wordpress-exporter-v2.
 *
 * It demonstrates how plugins can extend an export in various ways:
 *
 * 1. actually have "export filters" do something useful :-)
 * 2. add extension markup to the WXR generated by the exporter
 */

class SHC_WXR_Extension {
	/**
	 * The preferred namespace prefix for our extension markup.
	 *
	 * @var string
	 */
	const SHC_PREFIX = 'shc';

	/**
	 * The namespace-uri for our extension markup.
	 *
	 * @var string
	 */
	const SHC_NAMESPACE_URI = 'http://sparrowhawkcomputing.com/shc/';

	/**
	 * Whether we have written any extension markup.
	 *
	 * @var bool
	 */
	protected $extension_markup_written = false;

	/**
	 * Constructor.
	 */
	function __construct() {
		// add custom export filters
		add_action( 'admin_head', array( __CLASS__, 'output_js' ), 11 );
		add_action( 'export_filters', array( __CLASS__, 'render_filters' ) );

		// inform the exporter about the namespace for our extension markup
		add_filter( 'wxr_export_extension_namespaces', array( __CLASS__, 'our_namespace' ), 10, 2 );

		// handle the custom export filters we added
		add_filter( 'export_args', array( __CLASS__, 'export_args' ) );
		add_action( 'export_user_ids', array( __CLASS__, 'user_ids' ), 10, 2 );
		add_action( 'export_term_ids', array( __CLASS__, 'term_ids' ), 10, 2 );

		// output extension markup for various objects
		add_action( 'wxr_export_user', array( $this, 'user_extension_markup' ), 10, 2 );
		add_filter( 'wxr_export_skip_usermeta', array( __CLASS__, 'skip_usermeta' ), 10, 3 );
		add_action( 'wxr_export_term', array( $this, 'term_extension_markup' ), 10, 2 );
		add_action( 'wxr_export_post', array( $this, 'post_extension_markup' ), 10, 2 );
		add_action( 'wxr_export_comment', array( $this, 'comment_extension_markup' ), 10, 2 );
		add_action( 'wxr_export_meta', array( $this, 'meta_extension_markup' ), 10, 3 );

		// report back to the exporter whether we wrote any extension markup
		add_filter( 'wxr_export_extension_markup', array( $this, 'extension_markup_written' ) );
	}

	static function skip_usermeta( $default, $key, $meta ) {

		if ( ! in_array( $key, array( 'first_name', 'last_name' ) ) ) {
			return false;
		}

		return true;
	}

	/**
	 * Add export filters to allow exporting:
	 *
	 * 1. terms from specific taxonomies
	 * 2. specific users
	 *
	 * without exporting any posts
	 *
	 * The action this is hooked into in the standard exporter.  However, the
	 * necessary hooks to do ANYTHING with these export filters is not.  Those
	 * necessary hooks are in http://github.com/pbiron/wordpress-exporter-v2 and
	 * are taken advantage of in this plugin.
	 */
	static function render_filters() {
 ?>
 	<fieldset>
	 	<p><label><input type="radio" name="content" value="extension-taxonomies"> Taxonomies</label></p>
		<ul id="extension-taxonomies-filters" class="export-filters" style="display: none;">
			<li>
				<fieldset>
				<?php
				foreach ( get_taxonomies( array(), 'objects') as $tax ) {
				 ?>
				<label class="label-responsive">
					<input name="extension-taxonomies[]" id="taxonomies-<?php echo $tax->name ?>" type='checkbox' value='<?php echo $tax->name ?>'>
				 	<?php echo $tax->labels->name ?>
				 	<br />
				 </label>
				<?php
				}
				 ?>
				</fieldset>
			</li>
		</ul>
	</fieldset>
	<fieldset>
	 	<p><label><input type="radio" name="content" value="extension-users"> Users</label></p>
		<ul id="extension-users-filters" class="export-filters" style="display: none;">
			<li>
				<fieldset>
				<?php
				// a "real" plugin would probably also want to have dropdowns for roles, etc
				foreach ( get_users() as $user ) {
				 ?>
				<label class="label-responsive">
					<input name="extension-users[]" id="users-<?php echo $user->ID ?>" type='checkbox' value='<?php echo $user->ID ?>'>
				 	<?php echo $user->display_name ?>
				 	<br />
				 </label>
				<?php
				}
				 ?>
				</fieldset>
			</li>
		</ul>
	</fieldset>
<?php
	}

	/**
	 * Output JavaScript on the export page.
	 */
	static function output_js() {
		if ( defined( 'WXR_VERSION' ) && '1.2' === WXR_VERSION) {
			/*
			 * this demonstrates the lengths that plugins must go to to
			 * get the UI of anything hooked into 'export_filters' to behave
			 * like the "built-in" export filters with the standard exporter.
			 *
			 * It also demonstrates that even if a plugin goes to this length,
			 * a user doing an export with the standard exporter will be shocked
			 * to find that even if they set values for one of these filters
			 * that what gets exported is the same as if they had selected
			 * 'All content' :-(
			 *
			 * With the the exporter v2 plugin, we don't need this JS.
			 */
?>
<script type="text/javascript">
	jQuery(document).ready(function($) {
 		var form = $('#export-filters');
 		form.find('input:radio').change( function() {
			switch( $(this).val() ) {
				case 'taxonomies': $('#taxonomies-filters').slideDown(); break;
				case 'users': $('#users-filters').slideDown(); break;
			}
 		});
	});
</script>
<?php
		}
	}

	/**
	 * Filter the export args, so the exporter can understand the export filters we added
	 * by hooking into 'export_filters' above.
	 *
	 * @param array $args
	 * @return array
	 *
	 * This filter is in the standard exporter.  However, the necessary hooks to do
	 * ANYTHING with these export filters is not.  Those necessary hooks are in
	 * http://github.com/pbiron/wordpress-exporter-v2 and are taken advantage of in
	 * this plugin.
	 */
	static function export_args( $args ) {
		if ( 'extension-taxonomies' === $args['content'] ) {
			$args['extension-taxonomies'] = $_REQUEST['extension-taxonomies'];
		}
		elseif ( 'extension-users' === $args['content'] ) {
			$args['extension-users'] = array_map( 'intval', $_REQUEST['extension-users'] );
		}

		return $args;
	}

	/**
	 * Set the user IDs to be exported.
	 *
	 * @param array $term_ids
	 * @param array $filters
	 * @return array
	 */
	static function user_ids( $user_ids, $filters ) {
		if ( 'extension-users' === $filters['content'] && ! empty( $filters['extension-users'] ) ) {
			$user_ids = (array) get_users( array( 'include' => $filters['extension-users'], 'fields' => 'ID' ) );
	 	}

	 	return $user_ids;
	}

	/**
	 * Set the term IDs to be exported.
	 *
	 * @param array $term_ids
	 * @param array $filters
	 * @return array
	 */
	static function term_ids( $term_ids, $filters ) {
		if ( 'extension-taxonomies' === $filters['content'] && ! empty( $filters['extension-taxonomies'] ) ) {
			// export terms from the specified taxonomies
			$term_ids = (array) get_terms( array( 'taxonomy' => $filters['extension-taxonomies'], 'fields' => 'ids', 'hide_empty' => false ) );
	 	}

	 	return $term_ids;
	}

	/**
	 * Inform the exporter that we intend to output extension markup.
	 *
	 * @todo The $plugins param is actually an array of the hash below.  As far as I know
	 * there is no convention for this in the PHP Documentation Standards
	 * (https://make.wordpress.org/core/handbook/best-practices/inline-documentation-standards/php/#1-1-parameters-that-are-arrays)

	 * @param array $plugins {
	 *     @type string $prefix Our "preferred" namespace prefix.
	 *     @type string $namespace-uri The namespace-uri for our extension markup.
	 * }
	 * @param array $filters ???
	 * @return array
	 */
	static function our_namespace( $plugins, $filters ) {
		$plugins[] = array(
			'prefix' => self::SHC_PREFIX,
			'namespace-uri' => self::SHC_NAMESPACE_URI,
			);

		return $plugins;
	}

	/**
	 * Export custom markup for a user.
	 *
	 * In a "real" plugin, this might be used to export rows from a custom
	 * table.
	 *
	 * @param WP_XMLWriter $writer
	 * @param WP_User $user
	 */
	function user_extension_markup( $writer, $user ) {
		if ( $this->have_extension_markup_to_write( $user ) ) {
			$this->start_shc_element( $writer, 'custom_table_user_row' );

			$this->write_shc_element( $writer, 'col1', 'val 1' );
			$this->write_shc_element( $writer, 'col2', 'val 2' );

			$writer->endElement();

			$this->extension_markup_written = true;
		}
	}

	/**
	 * Export custom markup for a comment.
	 *
	 * In a "real" plugin, this might be used to export rows from a custom
	 * table.
	 *
	 * @param WP_XMLWriter $writer
	 * @param WP_Comment $comment
	 */
	function comment_extension_markup( $writer, $comment ) {
		if ( $this->have_extension_markup_to_write( $comment ) ) {
			$this->start_shc_element( $writer, 'custom_table_comment_row' );

			$this->write_shc_element( $writer, 'col1', 'val 1' );
			$this->write_shc_element( $writer, 'col2', 'val 2' );

			$writer->endElement();

			$this->extension_markup_written = true;
		}
	}

	/**
	 * Export custom markup for a meta.
	 *
	 * In a "real" plugin, this might be used to export rows from a custom
	 * table.
	 *
	 * @param WP_XMLWriter $writer
	 * @param object $meta
	 * @param string $type
	 */
	function meta_extension_markup( $writer, $meta, $type ) {
		if ( $this->have_extension_markup_to_write( $meta, $type ) ) {
			$this->start_shc_element( $writer, 'custom_table_meta_row' );

			// this demonstrates the need to pass $type...since the $meta object can have
			// different members depending on what type of meta it is :-(
			$this->write_shc_element( $writer, 'id', 'user' === $type ? $meta->umeta_id : $meta->meta_id );
			$this->write_shc_element( $writer, 'key', $meta->meta_key );
			$this->write_shc_element( $writer, 'value', $meta->meta_value );

			$writer->endElement();

			$this->extension_markup_written = true;
		}
	}

	/**
	 * Export custom markup for a term.
	 *
	 * In a "real" plugin, this might be used to export rows from a custom
	 * table.
	 *
	 * @param WP_XMLWriter $writer
	 * @param WP_Term $term
	 */
	function term_extension_markup( $writer, $term ) {
		if ( $this->have_extension_markup_to_write( $term ) ) {
			$this->start_shc_element( $writer, 'custom_table_term_row' );

			$this->write_shc_element( $writer, 'term_id', $term->term_id );
			$this->write_shc_element( $writer, 'col1', 'val 1' );
			$this->write_shc_element( $writer, 'col2', 'val 2' );

			$writer->endElement();

			$this->extension_markup_written = true;
		}
	}

	/**
	 * Export custom markup for a post.
	 *
	 * In a "real" plugin, this might be used to export rows from a custom
	 * table that are associated with a post.
	 *
	 * @param WP_XMLWriter $writer
	 * @param WP_Post $post
	 */
	function post_extension_markup( $writer, $post ) {
		if ( $this->have_extension_markup_to_write( $post ) ) {
			// this attribute will be written on item, and thus needs
			// to be in a namespace
			$writer->writeAttribute( 'Q{' . self::SHC_NAMESPACE_URI . '}foo', 'bar' );


			$this->start_shc_element( $writer, 'custom_table_post_row' );

//			$writer->startElement( 'custom_table_post_row', self::SHC_NAMESPACE_URI );

			// this attribute will be written on shc:custom_table_post_row
//			$writer->writeAttribute( 'foo', 'bar' );

//			$writer->writeElement( 'post_id', $post->ID, self::SHC_NAMESPACE_URI );
			$this->write_shc_element( $writer, 'post_id', $post->ID );

			// this attribute will NOT be written because WP_XMLWriter will
			// detect that XMLWriter would generate an error were it to be written
			// since child elements have already been written.
//			$writer->writeAttribute( 'foo', 'bar' );
//			$writer->writeElement( 'col1', 'val1', self::SHC_NAMESPACE_URI );
//			$writer->writeElement( 'col2', 'val2', self::SHC_NAMESPACE_URI );
			$this->write_shc_element( $writer, 'col1', 'val 1' );
			$this->write_shc_element( $writer, 'col2', 'val 2' );

			$writer->endElement();

			$this->extension_markup_written = true;
		}
	}

	/**
	 * Report back to the exporter whether we have written any extension markup.
	 *
	 * @param array $plugins
	 * @return array
	 */
	function extension_markup_written( $plugins ) {
		if ( $this->extension_markup_written ) {
			$plugin_data = get_plugin_data( __FILE__ );

			$plugins[] = array(
				'namespace-uri' => self::SHC_NAMESPACE_URI,
				'plugin-name' => $plugin_data['Name'],
				'plugin-slug' => basename( __DIR__ ) . '/' . basename( __FILE__ ),
				'plugin-uri' => $plugin_data['PluginURI'],
			);
		}

		return $plugins;
	}

	/**
	 * Simulate whether to add extension markup for a given object.
	 *
	 * In a "real" plugin, this might check the properties of the object
	 * (a user, term, post, etc) in question, do a lookup in a custom table/etc
	 * and return true IFF there is real extension markup to output.
	 *
	 * @return bool
	 */
	private function have_extension_markup_to_write( $object ) {
		return 1 == rand( 0, 1 );
	}

	private function start_shc_element( $writer, $localName, $attributes = array() ) {
		$writer->startElement( 'Q{' . self::SHC_NAMESPACE_URI . '}' . $localName, $attributes );
	}

	private function write_shc_element( $writer, $localName, $content, $attributes = array() ) {
		$writer->writeElement( 'Q{' . self::SHC_NAMESPACE_URI . '}' . $localName, $content, $attributes );
	}
}
// instantiate ourselves
new SHC_WXR_Extension();

 ?>